var searchIndex = {};
searchIndex["mime_multipart"] = {"doc":"","items":[[3,"Part","mime_multipart","A multipart part which is not a file (stored in memory)",null,null],[12,"headers","","",0,null],[12,"body","","",0,null],[3,"FilePart","","A file that is to be inserted into a `multipart/*` or alternatively an uploaded file that\nwas received as part of `multipart/*` parsing.",null,null],[12,"headers","","The headers of the part",1,null],[12,"path","","A temporary file containing the file content",1,null],[12,"size","","Optionally, the size of the file.  This is filled when multiparts are parsed, but is\nnot necessary when they are generated.",1,null],[4,"Node","","A multipart part which could be either a file, in memory, or another multipart\ncontainer containing nested parts.",null,null],[13,"Part","","A part in memory",2,null],[13,"File","","A part streamed to a file",2,null],[13,"Multipart","","A container of nested multipart parts",2,null],[5,"parse_multipart","","Parse a MIME `multipart/*` from a `Read`able stream into a `Vec` of `Node`s, streaming\nfiles to disk and keeping the rest in memory.  Recursive `multipart/*` parts will are\nparsed as well and returned within a `Node::Multipart` variant.",null,{"inputs":[{"name":"s"},{"name":"bool"}],"output":{"name":"result"}}],[5,"parse_multipart_body","","Parse a MIME `multipart/*` from a `Read`able stream into a `Vec` of `Node`s, streaming\nfiles to disk and keeping the rest in memory.  Recursive `multipart/*` parts will are\nparsed as well and returned within a `Node::Multipart` variant.",null,{"inputs":[{"name":"s"},{"name":"headers"},{"name":"bool"}],"output":{"name":"result"}}],[5,"get_multipart_boundary","","Get the `multipart/*` boundary string from `hyper::Headers`",null,{"inputs":[{"name":"headers"}],"output":{"name":"result"}}],[5,"generate_boundary","","Generate a valid multipart boundary, statistically unlikely to be found within\nthe content of the parts.",null,{"inputs":[],"output":{"name":"vec"}}],[5,"stream_multipart","","Stream a multipart body to the output `stream` given, made up of the `parts`\ngiven.  Top-level headers are NOT included in this stream; the caller must send\nthose prior to calling stream_multipart().",null,{"inputs":[{"name":"s"},{"name":"vec"},{"name":"vec"}],"output":{"name":"result"}}],[0,"error","","",null,null],[4,"Error","mime_multipart::error","An error type for the `mime-multipart` crate.",null,null],[13,"NoRequestContentType","","The Hyper request did not have a Content-Type header.",3,null],[13,"NotMultipart","","The Hyper request Content-Type top-level Mime was not `Multipart`.",3,null],[13,"BoundaryNotSpecified","","The Content-Type header failed to specify boundary token.",3,null],[13,"PartialHeaders","","A multipart section contained only partial headers.",3,null],[13,"EofInMainHeaders","","",3,null],[13,"EofBeforeFirstBoundary","","",3,null],[13,"NoCrLfAfterBoundary","","",3,null],[13,"EofInPartHeaders","","",3,null],[13,"EofInFile","","",3,null],[13,"EofInPart","","",3,null],[13,"Httparse","","An HTTP parsing error from a multipart section.",3,null],[13,"Io","","An I/O error.",3,null],[13,"Hyper","","An error was returned from Hyper.",3,null],[13,"Utf8","","An error occurred during UTF-8 processing.",3,null],[13,"Decoding","","An error occurred during character decoding",3,null],[11,"from","","",3,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",3,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",3,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",3,{"inputs":[{"name":"fromutf8error"}],"output":{"name":"error"}}],[11,"fmt","","",3,null],[11,"fmt","","",3,null],[11,"description","","",3,null],[11,"eq","mime_multipart","",0,null],[11,"ne","","",0,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"content_type","","Mime content-type specified in the header",0,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"new","","",1,{"inputs":[{"name":"headers"},{"name":"path"}],"output":{"name":"filepart"}}],[11,"do_not_delete_on_drop","","If you do not want the file on disk to be deleted when Self drops, call this\nfunction.  It will become your responsability to clean up.",1,null],[11,"create","","Create a new temporary FilePart (when created this way, the file will be\ndeleted once the FilePart object goes out of scope).",1,{"inputs":[{"name":"headers"}],"output":{"name":"result"}}],[11,"filename","","Filename that was specified when the file was uploaded.  Returns `Ok&lt;None&gt;` if there\nwas no content-disposition header supplied.",1,null],[11,"content_type","","Mime content-type specified in the header",1,null],[11,"drop","","",1,null],[11,"fmt","","",2,null],[11,"clone","","",2,null]],"paths":[[3,"Part"],[3,"FilePart"],[4,"Node"],[4,"Error"]]};
initSearch(searchIndex);
